
## Debug

### Сервер не отвечает, как можно получить доступ к серверу, не находясь непосредственно в ЦОДе

- Ответ
    
    tcpconsole, ipmi, kvm
    
    Написать тикет в цод, чтобы потыкали
    

---

### Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?

- Ответ
    
    502 bad gateway, ошибка на стороне вышестоящего сервера. То есть nginx сообщает о том, что получил ответ от другого сервера, к которому он обращался - некорректный или непонятный. 
    И тут уже надо копать что там в логах у вышестоящего сервера не так.
    
    Если брать nginx+apache
    
    Как минимум нужно посмотреть конфиги nginx, подрубить логгирование. И проверить параметры. Как минимум там должно быть такое:
    
    ```bash
    server {
        listen 80;
        server_name landing.example.com;
    
        location / {
    			proxy_pass                  http://my_server;
          proxy_set_header            Host $host;
          proxy_set_header            X-Real-IP $remote_addr;
          proxy_http_version          1.1;
          proxy_set_header            X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header            X-Forwarded-Proto http;
          proxy_redirect              http:// $scheme://;
        }
    
        access_log /landing-access.log;
        error_log  /landing-error.log info;
    }
    ```
    Обращаем внимание на proxy_pass. Это то, куда у нас пошел запрос.
    А дальше действуем по ситуации. Перезапускаем сервис, смотрим логи этого приложения, или, как в данном случае можно еще посмотреть логи сервера apache.
    Впрочем, это касается всех ошибок 5xx.
    

---

### В директории находится файл с нечитаемым содержимым. Каким образом можно узнать  формат хранения данных и предназначение файла?

- Ответ
    Поможет команда `file`. Она в большинстве случаев показывает что это за файл по своей сути.
    ```bash
    $ file stat-master.zip
    stat-master.zip: Zip archive data, at least v1.0 to extract

    $ file unins000.exe
    unins000.exe: PE32 executable (GUI) Intel 80386, for MS Windows
    
    $ file -i -b unins000.exe
    application/x-dosexec; charset=binary
    ```
    

---

### Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?

- Ответ
    
    Причин подобного поведения несколько
    
    - Файл не существует.
    - Файл существует, но это символическая ссылка
    - Файл существует, но это 32 битный файл. И нужны библиотеки для его запуска.
    - Иногда из-за символов каких-нибудь, в питоне такое происходит, поудалять символы лишние нужно, в самом файле.
    - Нету интерпретатора в системе

---

### Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?

- Ответ
    
    Поможет утилита strace
    line-buffered в данном случае это опция, которая выведет результат как только найдет
    
    strace -f - отслеживание дочерныих процессов
    
    ```bash
    strace -f lftp sitename |& grep --line-buffered open | grep /home/akkana
    ```
    
    Либо в самой программе, если удастся найти параметры вывода проблемы. Как правило это -vvv, verbose
    
    ```bash
    /usr/sbin/mysqld --verbose --help | grep -A 1 "Default options"
    ```
    

---

### Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)

- Ответ
    
    1. Используем утилиту setfacl. По умолчанию её может не быть в системе, но не проблема установить.
    
   ```
   setfacl -m u::rwx,g::rx,o::x /usr/bin/chmod
   ```
    
    2 Можно запустить утилиту chmod, передав её явно динамическому компоновщику. В контексте данной заметки считайте компоновщик интерпретатором для программы chmod. В разных дистрибутивах он может иметь разное название и расположение. Пример для Debian 11:
   ``` 
   /usr/lib64/ld-linux-x86-64.so.2 /usr/bin/chmod +x /usr/bin/chmod**
   ```
    
    3 Можно скопировать права с любого исполняемого файла и записать содержимое утилиты chmod в этот файл. Получается рабочая копия chmod.
    Создаём пустой файл с правами утилиты ls.
    
    ```
    cp --attributes-only /usr/bin/ls ./new_chmod
    ```
    
   Копируем содержимое утилиты chmod в созданный файл:
   ``` 
   cat /usr/bin/chmod > ./new_chmod
   ```
    
    Можно использовать:
    ```
    /new_chmod +x /usr/bin/chmod
    ```
    
    4 Почти то же самое что и предыдущий вариант только проще:
   ``` 
   install -m 755 /usr/bin/chmod ./new_chmod
   ```
    
    или так:
    ```
    rsync --chmod=ugo+x /usr/bin/chmod ./new_chmod
    ```
    
    5 Если умеете программировать на какой-то языке, то можно с его помощью вернуть бит исполнения. Пример с python:
    ```
    python -c "import os;os.chmod('/usr/bin/chmod', 0755)"
    ```
    

---

### База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?

- Ответы
    
    ОПАСНО!!!: нужно выключить fsync, чтобы база не дожидалась записи с данных на диск, а как бы сохраняла. 
    
    Linux может отдавать успешную запись, когда он к себе положил в буфер, а не когда на диск засинкал. Это немного костыльный режим работы, даже скорее опасный, рискованный. Питание вырубят в этот момент, и все навернется. Но зато этот метод ускоряет запись на порядок. 
    

### Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?

- Ответы
    - Total. Эта цифра представляет всю существующую память.
    - Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.
    
    `used = total - free - buff/cache`
    
    - Free – свободная память в системе.
    - Shared – память, используемая (преимущественно) в tmpfs
    - Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
    - Available – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки.  
      В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент. (То есть то, что можно потенциально освободить. Кэш, буфер и тп)
    
    Вот и получается, что доступная память (available) как правило больше или равна свободной памяти (free)

---

### Что такое разделяемая память?
Привести примеры**

- Ответ
    Разделяемая память - это область памяти, которую могут использовать несколько процессов одновременно. Это один из способов межпроцессного взаимодействия, позволяющий различным процессам обмениваться данными без необходимости использования более сложных механизмов, таких как сокеты или каналы.

    Например, клиент и сервер.
    Клиент это терминал ввода. Сервер принимает данные. 
    Клиент вводит строку терминала. Строка передеается серверу через сегмент памяти. После чего информация выводится. 

    Более глобальные примеры:
    Базы данных. Общая память используется в бд, где ряд процессов обращаются к общим структурам данных, и манипулируют ими. 

    Веб сервера. Например, апач. Апач использует общую память для рабочих процесов. Что позволяет разным процессам обслуживать разные запросы. 

    Операционные системы. Например, linux использует общую память для IPC, кэширования файловой системы и других задач.

    Подробнее про такую память можно почитать тут:
    https://dev.to/0xog_pg/using-shared-memory-in-linux-1p62

    


---

### Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.
    
    Мы сняли с сервера нагрузку, но оставили кассандру и ELK запущенными. Надо понять что делает сервер тормозным.

- Ответ

    - Сначала делаем команду top, обратить внимание на sys time и 35% CPU, которое отъедало systemd. Соответственно, что-то там усиленно ядро творило в своем sys time
    - Чтобы увидеть что именно делает systemd можно запустить `strace -c -p 1`, это даст таблицу сисколов, среди которых `waitid` отъедал много ресурсов.(78% CPU времени кушало). Данный системный вызов используется во время ожидания изменения состояния процесса. 
    Отсюда предположение - systemd что-то порождает, оно падает, случается waitid и все это добро происходит быстро и в больших кол-вах
    - Далее смотрим что именно systemd может так усиленно плодить: `watch -n 1 ps --ppid 1`. Тут мы видим какие процессы активно форкаются.
    И в  таблице вывода замелькали сомнительные `a.out` и `a.sh`
    - Поиск по имени (`find / -name "a.sh" 2`> /dev/null) привел к скрипту /var/games/a.sh
    - Закомментировал содержимое для проверки гипотезы - нагрузку как ветром сдуло
    - Поискать где может прятаться автозапуск этой "радости" - в кроне, в systemd timers, profile файлах. Либо спрятано с особой выдумкой, либо было запущено вами вручную с последующей чисткой history.


---

### допустим у тебя есть бинарник который запускается и сразу падает, у него все файловые дискрипторы пустые, как бы ты искал решение проблемы?

- Ответ

   Есть утилита strace, с помощью которой можно отследить какие вызовы к ядру делает процесс приложения, которое падает
   Её можно использовать следующим образом:  
    ```
    strace ./my_crashing_binary
    strace ./my_crashing_binary 2>out.txt
    strace -p 12345 2>out.txt
    ```
    Пример вывода ошибки. Здесь мы видим что идет попытка обращения к файлу, которого нет. По итогу программа падает
    ```
    <snip>
    ...
    write(1, "Hello World\n", 12) = 12
    brk(0) = 0x940e000
    brk(0x942f000) = 0x942f000
    open("/myfile", O_RDONLY) = -1 ENOENT (No such file or directory)
    --- SIGSEGV (Segmentation fault) @ 0 (0) ---
    +++ killed by SIGSEGV (core dumped) +++
    ---
    ```

