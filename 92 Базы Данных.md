
## СУБД Базы Mysql

### Что такое индексы, зачем они нужны?

- Ответ
    
    Представьте себе, что у вас есть полочка для книг. При этом изначально эта полочка с книгами пуста. Книги вам то приносят, то уносят, то делают в них какие-то корректировки (к примеру, мемуары или может быть черновики) и тому подобное.
    
    Так как полочка маленькая, то вы как-то не особо задумывались о какой-либо системе классификации, а просто вставляете книги в любые пустые места.
    
    Каждый раз когда-то вам или кому-то необходимо найти определенную книгу, возникает необходимость просматривать все книги с самого начала полочки до первой попавшейся (если нужна только одна книга) или полностью все (если нужно собрать все копии). В принципе, для одной полочки это весьма необременительно.
    
    И нужно придумать систему классификации.
    
    Например, можно добавлять закладки в каталог.
    
    Поэтому вы поступаете проще, вы берете каталог, где возможно добавлять листочки. При этом каждую страницу выделяете только под одно название книги, а сами страницы располагаете в каталоге в порядке возрастания названий. Содержание этих страниц весьма просто — вы записываете в каком стеллаже, на какой полке и какой по счету является книга. Если книг несколько, то строчек в этой странице становится несколько.
    
    Таким образом, чтобы найти одну или все нужные книги по названию, вам достаточно открыть этот каталог и быстро пролистнуть до нужной страницы, а затем пройтись по всем указанным стеллажам. При этом для упрощения, вы также можете первые буквы названий так же индексировать. То есть добавляете наклейку на каждую первую страницу с указанной буквой (таким образом можете сразу перейти, например, к букве «Р», не пролистывая все названия до нее).
    
    Конечно, для поддержки такой системы требуется дополнительное время, но все же оно существенно меньше, чем попытка найти вслепую книгу из тысячи (пара минут против нескольких часов и более).
    
- Альтернативный ответ, ссылка на статью
    
    [https://infostart.ru/1c/articles/444987/](https://infostart.ru/1c/articles/444987/)
    

---

### Какая будет проблема если проставить много индексов?

- Ответ
    
    Причина того, что наличие большого количества индексов — это плохо, заключается в том, что это резко увеличивает объем операций записи, которые необходимо выполнить в таблице. Это происходит в нескольких разных местах. Когда происходит запись, данные сначала записываются в журнал транзакций. Когда это происходит, это регистрируется для каждого отдельного индекса, в который выполняется запись. Таким образом, для таблицы с девятью некластеризованными индексами в журнале транзакций выполняется 10 операций записи.
    
- Другой ответ, более полный
    
  1) **Накладные затраты при записи данных**
      
      Очевидно, что для поддержаиня какой-либо дополнительной структуры данных, либо определенной организации данных, требуется совершать дополнительные действия.
      
      Действий не так много, накладные затраты на них небольшие. Но плохо то, что эти затраты и действия возникают при записи данных. А запись данных происходит в транзакции.
      
      Хуже если в транзакции происходит и запись и чтение данных (контроль остатков). В этом случае индекс должен быть всегда в актуальном состоянии.
      
      Затраты на запись или чтение в транзакции намного "дороже" внетранзакционных издержек. Дело в том, что запись может вестись строго последовательно, и время на фиксацию изменений в БД сократить достаточно сложно. Более мощное оборудование тут не всегда помогает.
      
      Внетранзакционное же чтение данных может вполне успешно выполняться параллельно, при этом в случае увеления количества запросов на чтение данных, к примеру, вследствие роста количества пользователей, то они вполне могут решиться наращиванием аппаратных ресурсов.
    
  2) **Накладные затраты на обслуживание индексов**
      
      При интенсивной записи данных в таблицу данные индексов к ней не всегда распологаются на той странице, на которой должны. Появляются "пропуски", физическая структура индексов становится неэффективной. Поэтому иногда бывает необходимо производить дефрагментацию индексов. Производительность запросов к СУБД во время дефрагментации, соответственно, падает. Есть ещё процесс полного перестроения индексов - но в современных версиях MS SQL необходимости выполнения данной операции по регламенту нет.
      
  3) **Влияние индексов на размер базы**
      
      Не самое страшное последствие, но так или иначе если база весит 150-200 ГБ, то об этом надо уже задуматься. Для средней OLTP базы размер индексов, как правило, превышает объём самой базы.
      
      Не верите? Вполне можете воспользоваться какой-либо обработкой вроде этой:
      
      [//infostart.ru/public/19463/](https://infostart.ru/public/19463/)
      
      и посмотреть, сколько же в вашей базе места занимают индексы.
      
  4) **Затраты на создание и поддержание актуальной статистики**
      
      Статистику в базе нужно регулярно обновлять при интенсивных операциях вставки и обновления. Это занимает вычислительные ресурсы, хоть и не влияет непосредственно на процесс. Рекомендовано и в некоторых БД реализуется автоматически обновление статистики ночью, в период офф-пика, когда executor nodes нельзя полностью гасить, но можно занять их несрочной работой.
      
      Неактуальная статистика может привести к проблемам производительности системы.
      
      Но это не значит, что индексы - это плохо, без них СУБД были бы бесполезны.
      
    **Плохи индексы, которые не используются.**

---

### Как настроить мастер слейв репликацию в мускуле?

- Ответ
    
    Необходимы 2 сервера: master и slave.
    
    1. На оба сервера устанавливаем сервер MySQL одинаковой версии.
    2. Включаем сервер базы данных на обоих серверах.
    3. Настраиваем **master** - в `/etc/my.cnf` устанавливаем следующие значения:  
    ```bash
    # выбираем ID сервера, произвольное число, лучше начинать с 1
    server-id = 1

    # путь к бинарному логу
    log_bin = /var/log/mysql/mysql-bin.log

    # название Вашей базы данных, которая будет реплицироваться
    binlog_do_db = newdatabase
    ```
    Перезапускаем сервер базы данных.  

    4. Подключаемся к **master** серверу, создаем пользователя и назначаем ему права для выполнения репликации.  
    ```bash
    mysql -u root -p <пароль root сервера БД>
    GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'%' IDENTIFIED BY 'password';
    FLUSH PRIVILEGES;
    ```
    
    5. На master сервере делаем дамп базы данных c блокировкой таблиц.  
    ```bash
    mysqldump -u root -p --lock-all-tables newdatabase > newdatabase.sql
    ```
    
    6. Переносим дамп базы на slave сервер, создаем базу данных с таким же именем и импортируем базу. 
    ```bash
    CREATE DATABASE newdatabase;
    mysql -u root -p newdatabase < newdatabase.sql
    ```
    
    7. Настраиваем slave в `/etc/my.cnf`:  
    ```bash
    # ID Слейва, удобно выбирать следующим числом после Мастера
    server-id = 2
    # Путь к relay логу
    relay-log = /var/log/mysql/mysql-relay-bin.log
    # Путь к bin логу на Мастере
    log_bin = /var/log/mysql/mysql-bin.log
    # База данных для репликации
    binlog_do_db = newdatabase
    ```
    Перезапускаем сервер базы данных.  
    
    8. Запускаем репликацию на slave сервере.  
    ```bash
    CHANGE MASTER TO MASTER_HOST='10.10.0.1', MASTER_USER='slave_user', MASTER_PASSWORD='password',
    MASTER_LOG_FILE = 'mysql-bin.000001', MASTER_LOG_POS = 107;
    # Указанные значения мы берем из настроек Мастера
    После этого запускаем репликацию на Слейве:
    START SLAVE;
    ```
    
    9. Проверяем статус репликации:  
    ```bash
    SHOW SLAVE STATUSG
    ```
    
---

### В чем разница между TRUNCATE DELETE и DROP?

- Ответ  
    Тут важно понимать что от базы к базе поведение данных операций может отличаться.  
    1. Оператор `DROP` используется для удаления **структуры** таблицы. После удаления индексы, ограничения и триггеры, зависящие от таблицы, также будут удалены, но функции и хранимые процедуры, которые зависят от таблицы, останутся, но станут недействительными. Операция необратимая. Это операция **DDL** (Data Definition Language). Бытовая аналогия - снести целый дом.  
    2. Оператор `DELETE` используется для удаления **данных** в таблице, его можно удалить с помощью условий, и все данные в таблице удаляются без условий. Операция откатываемая. Дольше работает, поскольку информация для отката записывается. Блокирует только удаляемые строки, а не всю таблицу. Это операция **DML** (Data Manipulation Language).  Бытовая аналогия - выбросить какие-то отдельные вещи из дома.   
    3. Оператор `TRUNCATE` используется для удаления всех данных в таблице.  Операция быстрая и эффективная, ибо **не хранит подробную операцию для отмены**. Необратимая операция. На время работы блокирует таблицу. Это также операция **DDL**.  Бытовая аналогия - выбросить содержимое дома, но оставить сам дом.   

    * **DDL** (Data Definition Language) - язык определения данных. Операции изменяют структуру базы данных (CREATE,ALTER,DROP,TRUNCATE)  
    * **DML** (Data Manipulation Language) - язык манипулирования данными. То есть работают с содержимым таблиц (SELECT,INSERT,UPDATE,DELETE)  

    Основное отличие в том, что **DDL** работают со структурой базы данных и обычно необратимы.  
    А **DML** операции работают с данными внутри таблиц и могут быть отменены до подтверждения транзакции.  

---

## Что такое роли в pgsql

- Ответ
    
    **PostgreSQL** использует концепцию ролей (*roles*) для управления разрешениями на доступ к базе данных. 
    
    Роль можно рассматривать как пользователя базы данных или как группу пользователей, в зависимости от того как роль настроена.
    
    Роли могут владеть объектами базы данных (например, таблицами) и выдавать другим ролям разрешения на доступ к этим объектам, управляя тем, кто имеет доступ и к каким объектам.
    
    Кроме того, можно предоставить одной роли *членство* в другой роли, таким образом одна роль может использовать привилегии других ролей.
    
    Концепция ролей включает в себя концепцию пользователей ("users") и групп ("groups"). До версии 8.1 в PostgreSQL пользователи и группы были отдельными сущностями, но теперь есть только роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.
    
---

### Почему не следует использовать утилиту mysqldump на большой активной базе данных? Какие Вы знаете альтернативы?  

- Ответ
  
    Потому что может произойти блокировка таблиц. И любые изменения данных будут ожидать полного окончания дампа.  
    Из-за этого приложение фактически перестает работать.  
    Поэтому во время снятия дампа  нужно отключить блокировку таблиц.  

Можно использовать ключ `--single-transaction`, который позволит прочитать базу, и потом уже делать дамп. Это создаст корректный дамп.  
`--skip-lock-tables` - помогает в случаях когда у нас есть движок MYIASAM. И это позволяет избежать несогласованности данных.  

---

### Аббревиатура ACID, как расшифровывается?

- Ответ

    - **Atomicity** (Атомарность) - говорит что каждая транзакция является неделимой единицей работы, 
    и либо выполняется полностью, либо не выполняется вовсе.  
    - **Consistency** (Согласованность) - обеспечивает, что транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние. То есть, из одного валидного состояния в другое.  
    Допустим, есть правило что баланс счета не должен быть минусовой, Consistency гарантирует, что после транзакции ни один из балансов не будет минусовой
    - **Isolation** (Изоляция) - каждая транзакция должна выполняться изолированно от других транзакций.  
    Допустим две транзакции не могут одновременно работать с одними данными в один момент времени.
    - **Durability** (Долговечность) - после того как транзакция была успешно завершена, изменения должны остаться в базе данных, даже если что-то отъебнет.  
    
---

### Как безопасно удалить или изменить миллион строк в базе данных?  
- Ответ  
  
  Если просто в лоб удалять таблицу через DELETE, то мы можем столкнуться с блокировками таблицы. То есть таблица какое-то время будет недоступна.   
  Также можно столкнуться с повышенной нагрузкой на систему, что также замедлит общую производительность запросов.  
  1. Создать временную таблицу, с той же структурой, что и у текущей таблицы. Скопировать туда нужные данные. Потом переименовать таблицы. И удалить старую ненужную. В некоторых случаях это быстрее.  
  2. Порционное удаление. То есть мы разбиваем удаление по частям, например по 1000 записей. Можно оставить задержку между удалением. (Нужно это делать в транзакции).  
  3. Нужно найти время, когда нагрузка на базу минимальная. Как правило, это ночное время.  
  4. На всякий случай создать резервную копию базы.  

---

### Что такое wal-файл и зачем он нужен?  
- Ответ  
  WAL (Write-Ahead Logging) - механизм журналирования в PostgreSQL который записывает все изменения данных перед тем, как они попадут на диск.       
  По сути это страховка для базы данных, помогающая не потерять данные, если что-то пойдет не так.    

  Задачи:    
  1. Обеспечение целостности и надежности данных  
    * В случае сбоя системы или краха данных  
    * При внезапном отключении питания  
    * При аппаратных проблемах  
  
  2. Репликация  
    * Wal используется для синхронизации реплик  
    * Обеспечивает последовательное применение изменений  

  3. Оптимизация производительности  
    * Изменения сначала записываются в wal файл (быстрая последовательная запись)  
    * После чего происходит асинхронное обновление основных файлов базы (медленные случайные операции I/O)  
  
  4. Point-in-time-recovery   
    * Позволяет восстановить базу данных на любой момент времени  
    * Помогает при случайном удалении или повреждении данных  
    * Позволяет откатиться к определенной точке  

---
