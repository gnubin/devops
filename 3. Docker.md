***
 [[Вопросы по Doker на собеседовании| ВОПРОСЫ НА СОБЕСЕДОВАНИИ]]
 ***
# Контейнеризация

Контейнеризация и виртуализация — это два разных подхода к изоляции и управлению приложениями и их окружением.

Плюсы и минусы одной строкой:

**Контейнеризация:** легковесность, быстрый запуск, высокая плотность развертывания, переносимость, эффективное использование ресурсов, масштабирование, меньшая безопасность из-за использования общего ядра ОС

**Виртуализация:** полная изоляция, безопасность, совместимость с legacy-приложениями, накладные расходы по ресурсам выше

Подробная статья о ключевых различиях - [https://www.itc.by/kontejnery-i-virtualnye-mashiny-v-chem-klyuchevye-razlichiya/](https://www.itc.by/kontejnery-i-virtualnye-mashiny-v-chem-klyuchevye-razlichiya/)

## Docker

Будем рассматривать Docker, как самую известную и популярную платформу контейнеризации (хотя существует и множество других).

**Docker** — это платформа для разработки, развертывания и управления приложениями в **изолированных контейнерах**. Контейнеры позволяют упаковать приложение со всеми его зависимостями (библиотеками, настройками, переменными среды) в единый переносимый модуль, который может работать на любой системе с Docker.

**Образ** (Image) - шаблон приложения для создания контейнеров, хранит код приложения, зависимости, параметры. Хранятся образы в docker registry (хранилище образов, публичные - например, Docker Hub или приватные).

  
**Dockerfile** - набор инструкций для сборки образа  

### К**акие есть best practices для написания Dockerfile?**

1. Запускать только один процесс на контейнер.
2. Стараться объединять несколько команд RUN в одну для уменьшения количества слоёв образа.
3. Частоизменяемые слои образа необходимо располагать ниже по уровню, чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все нижеследующие слои будут пересобираться.
4. Указывать явные версии образов в инструкции FROM, чтобы избежать случая, когда выйдет новая версия образа с тегом **latest**.
5. При установке пакетов указывать версии пакетов.
6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
7. Использовать multistage build для сборки артифакта в одном контейнере и размещении его в другом.
8. COPY вместо ADD (ADD умеет качать файлы с url/распаковывать архивы, COPY - нет)

**Multistage Build**  
При многоэтапной сборке вы используете несколько операторов FROM в вашем Dockerfile. Каждая инструкция FROM использует произвольный базовый образ и начинает новый этап сборки. Вы можете выборочно копировать артефакты с одного этапа на другой, оставляя только то, что вам необходимо в конечном образе. Чтобы показать, как это работает, давайте адаптируем Dockerfile из предыдущего раздела для этого процесса.

Dockerfile:

`FROM golang:1.7.3 WORKDIR /go/src/github.com/alexellis/href-counter/ RUN go get -d -v golang.org/x/net/html COPY app.go . RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR /root/ COPY --from=0 /go/src/github.com/alexellis/href-counter/app . CMD ["./app"]`

**Docker Engine** - демон, движок, запускающий контейнеры, стоит на хостовой ОС.

**Контейнер** - запущенный образ приложения, работает как отдельный процесс на хостовой ОС.

### **Namespaces, cgroups, capabilities и overlayfs в Docker**

Docker использует несколько ключевых технологий Linux для изоляции процессов, управления ресурсами и обеспечения безопасности.

**Namespaces** — это механизм ядра Linux, который обеспечивает изоляцию различных аспектов системы для процессов. Docker использует пространства имён, чтобы контейнеры не влияли друг на друга и на хост-систему.

![](https://img2.teletype.in/files/15/9b/159bfbc8-a385-4db8-90ca-ed199be9d939.png)

**cgroups** — это механизм ядра Linux для ограничения и учёта ресурсов (CPU, RAM, I/O и т. д.). Docker использует cgroups, чтобы:

- Ограничивать ресурсы контейнера (например, не дать ему сожрать всю память).
- Управлять приоритетами (CPU shares, disk I/O).

**Capabilities (возможности процесса)**

В Linux процессы с **root-правами (UID 0)** имеют полный доступ к системе. Docker использует **capabilities**, чтобы ограничить права контейнера, даже если внутри он запущен от root.

**OverlayFS**

Docker использует **OverlayFS** (или другие драйверы хранения, например `aufs`, `btrfs`) для эффективного хранения образов и контейнеров с точки зрения экономии дисковых ресурсов

Как работает OverlayFS?

1. **Lower Dir (read-only)** — базовый слой (образ, например `alpine:latest`).
2. **Upper Dir (read-write)** — изменения в контейнере.
3. **Merged Dir** — виртуальная файловая система, объединяющая оба слоя.

Подробная документация в виде перевода статьи в 6 частях:  
[Часть 1: основы](https://habr.com/post/438796/)  
→ [Часть 2: термины и концепции](https://habr.com/post/439978/)  
→ [Часть 3: файлы Dockerfile](https://habr.com/post/439980/)  
→ [Часть 4: уменьшение размеров образов и ускорение их сборки](https://habr.com/post/440658/)  
→ [Часть 5: команды](https://habr.com/post/440660/)  
→ [Часть 6: работа с данными](https://habr.com/post/441574/)

***
#devops  #docker