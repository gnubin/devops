
## GIT

### Чем `merge` отличается от `rebase`?

- Ответ
    - `git merge` - выполняет слияние коммитов из одной ветки в другую. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.
        
        ![https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-merge.png](https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-merge.png)
        
        *Преимущества*:
        
        1. Простота,
        2. Сохраняет полную историю и хронологический порядок,
        3. Поддерживает контекст ветки.
        
        *Недостатки*:
        
        4. История коммитов может быть заполнена (загрязнена) множеством коммитов,
        5. Отладка с использованием git bisect может стать сложнее.
    - `git rebase` - сжимает все изменения в один патч. Затем интегрирует патч в целевую ветку. В отличии от *merge*, *rebase* перезаписывает историю, потому что она передаётся завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.
        
        ![https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-rebase.png](https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-rebase.png)
        
        *Преимущества*:
        
        1. Упрощает потенциально сложную историю,
        2. Упрощение манипуляций с единственным коммитом,
        3. Избежание слияния коммитов в занятых репозиториях и ветках,
        4. Очищает промежуточные коммиты, делая их одним коммитом, что полезно для DevOps команд.
        
        *Недостатки*:
        
        1. Сжатие фич до нескольких коммитов может скрыть контекст
        2. Перемещение публичных репозиториев может быть опасным при работе в команде,
        3. Появляется больше работы,
        4. Для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно.
---

### Когда нужно использовать `merge`, когда `rebase`?

- Ответ
    
    Предназначение этих команд git – интеграция изменений из одной ветки в другую, но делают они это по-разному.
    
    Предположим, у вас сложилась такая ситуация:
    
    ```
    A <- B <- C    [master]
    ^
     \
      D <- E       [branch]
    ```
    
    После обычного мержа репозиторий будет выглядеть так:
    
    ```
    A <- B <- C
    ^         ^
     \         \
      D <- E <- F
    ```
    
    А после `git rebase`– так:
    
    ```
    A <- B <- C <- D <- E
    ```
    
    Rebase указывает на то, что коммиты нужно буквально перенести со старого места на новое.
    
    Что выбрать?
    
    - Если вы сомневаетесь, то используйте обычное слияние.
    - Выбор между merge и rebase обусловлен тем, какой вы хотите видеть историю коммитов: линейной или ветвящейся.
    
    Учитывайте следующие факторы:
    
    1. Если ветка, в которую вы хотите внести изменения доступна для других разработчиков (например, в open source проекте), не используйте rebase. Эта команда удаляет ветку целиком и приводит к рассинхронизации копий
    репозиториев.
    2. Представляет ли исходная ветка ценность? Некоторые команды работают
    по принципу «одна функция – одна ветка», при этом ветка идентифицирует
    последовательность коммитов. В модели «один разработчик – одна ветка» в
    этом нет особой необходимости, так как автор коммита известен.
    3. Не захотите ли вы вдруг отменить слияние? Возврат rebase значительно затруднен по сравнению с обычным слиянием, а иногда даже невозможен.

---

### Чем отличается git pull и git fetch

- Ответ
    
    При использовании `pull`, git пытается сделать всё за вас. Он сливает любые внесённые коммиты в ветку, в которой вы сейчас работаете. 
    
    Команда `pull` автоматически сливает коммиты, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.
    
    При использовании `fetch`, git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку
    
- Краткий ответ
    
    git pull — это, по сути, команда git fetch, после которой сразу же следует git merge.
    
    Команда git fetch получает изменения с сервера и сохраняет их в каталог refs/remotes/. Это действие (fetch) не влияет на локальные ветки и текущие изменения, просто изменения с удаленного сервера скачиваются в директорию локального репозитария.
    
---

### Что такое cherry pick ?

- Ответ
    
    Команда `git cherry-pick` используется для перенесения 
    отдельных коммитов из одного места репозитория в другое, обычно между 
    ветками разработки и обслуживания. Этот механизм отличается от привычных
     команд git merge и git rebase, которые переносят коммиты целыми 
    цепочками.
    
---

### Какие пратики работы с гитом вы знаете? Форки

- Ответ
    
    Работа через форки принципиально отличается от других популярных методов организации командной разработки. Вместо того чтобы использовать один серверный репозиторий в качестве центральной кодовой базы, здесь каждый разработчик получает свой собственный репозиторий. Чаще всего эта модель применяется в общедоступных open source проектах.
    
    Основное преимущество forking workflow заключается в том, что все изменения вносятся без загрязнения истории проекта. Разработчики делают push в собственные репозитории, а доступ к центральному есть только у менеджера.
    
    Когда обновление готово к интеграции, программист делает pull-запрос в главный репозиторий, а менеджер одобряет и вносит его.

    В принципе какие сть форки:
     - central workflow - когда все сразу с мастер пушится 
     - trunk based - есть 3 ветки: мастер, дев, фьечер.
       основные особенности такой разработки что ветки живут недолго, что есть флаги которыми можно выключить и включать фичи, код в мастере почти всегда готов к деплою даже если в нем есть недоработанные фичи, постоянное код ревью кода (ревью пару минут на микро изменения и мерж)
     - gitflow 

    ![по подробнее почитать про trunk based development](https://habr.com/ru/articles/519314/)
    
---

### Что такое GitFlow?

- Ответ
    
    [Модель gitflow](https://proglib.io/p/git-github-gitflow/) использует две параллельные «долгие» ветки для хранения истории проекта: master и develop.
    
    - **Master** – это полностью готовое к релизу состояние со всеми пройденными тестами.
        - **Hotfix** – ветки обслуживания, или хотфиксы, которые
        используются для быстрых патчей. Они очень похожи на feature, но вместо
        develop-ветки базируются на master.
    - **Develop** – ветка, в которой объединяются и тестируются все отдельные разработки. После прохождения проверок они отправляются в master.
        - **Feature** – отдельная ветка для каждой новой функциональности, изменения из которой отправляются в develop.
    
   ![gitflow-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2022.png)

