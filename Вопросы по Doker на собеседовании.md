***
СОДЕРЖАНИЕ

***
### **Что такое контейнеризация? Чем она отличается от виртуализации?**


Если говорить о виртуальных машинах, там они работают через **Виртуализацию**

И машины создаются с помощью гипервизора. И все аппаратные составляющие создаются через нее. И затем на нее накатываются операционные системы.
Соответственно, ресурсы машины будут уходить на поддержание работы запущенной операционной системы.

При контейнеризации аппаратные ресурсы выделяются с помощью ядра операционной системы, и изолируются пространством имен. Следовательно, они потребляют меньше ресурсов, и быстрее пересоздаются.

Плюсы:

- Меньше ресурсов потребляется
- Быстрый запуск

---
### Что такое docker и какие инструменты linux лежат в основе? Для чего он используется?

- Ответ
    
    Docker базируется на технологиях **namespaces**, **cgroups**, **capabilities**, **overlay**
    **namespaces** - обеспечивает изоляцию. Используется для изоляции. Например, можно айдишники процессов разместить в разных контейнерах.
    **cgroup** - штука, которая позволяет управлять группой процессов, и управлять их ресурсами.
    **capabilites** - штука, которая позволяет дать некоторые рут привелегии процессам или исполняемым файлам. Например, изменить UID процесса на 0, или дать возможность монтировать файловые системы.
    **overlay (overlayFS, overlay2-драйвер)** - файловая система, которая умеет работать "слоями". Не сохранять каждый раз новые файлы, а наслаивать один слой на другой, тем самым экономя место на диске и время создания контейнера. 
    
    А вот докер - это уже штука, которая всеми этими технологиями рулит. Да ещё и удобным для нас образом.
    
    

    Компоненты докера:  
    1. Docker Daemon — то самое Container Engine; запускает контейнеры.
    2. Docker CII — утилита по управлению Docker.
    3. Dockerfile — инструкция по тому, как собирать образ.
    4. Image — образ, из которого раскатывается контейнер.
    5. Container.
    6. Docker registry — хранилище образов.
    
    ![docker-basic-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%209.png)
    
    На Docker_host работает Docker daemon, запускает контейнеры. Есть Client, который передаёт команды: собери образ, скачай образ, запусти контейнер. Docker daemon ходит в registry и выполняет их. Docker-клиент может обращаться и локально (к юникс-сокету), и по TCP с удалённого хоста.
    
    
    Docker daemon (демон)
    
    — это серверная часть, она работает на хост-машине: скачивает образы и запускает из них контейнеры, создаёт сеть между контейнерами, собирает логи. Когда мы говорим «создай образ», этим тоже занимается демон.
    
    Docker CLI
    
    — клиентская часть Docker, консольная утилита для работы с демоном. Повторю, она может работать не только локально, но и по сети.
    

---
### Что такое контейнеры, образы? В чём заключаются концепции их использования?

- Ответ
    
    **Образ** - шаблон приложения, который содержит слои файловой системы в режиме "только-чтение".
    
    **Контейнер** - запущенный образ приложения, который кроме нижних слоев в режиме "только чтение" содержит верхний слой в режиме "чтение-запись".
    
    Контейнер - это уже развернутое и запущенное приложение. Однажды запущенный контейнер сохранён в библиотеке, его можно останавливать, менять настройки, перезапускать, но до удаления контейнера это некоторая постоянная сущность со своим id. Продолжая аналогию с установкой ПО, контейнер можно сравнить с уже установленной и работающей программой на ПК.
    
    Образ - Это неизменяемый образ, из которого разворачивается контейнер. Его можно рассматривать как набор файлов, необходимых для запуска и работы приложения на другом хосте. Можно привести аналогию из мира установки ПО: образ — это компакт-диск, с которого устанавливается программа.
    

---

### В каком виде хранятся образы? Для чего используются слои? Что представляет собой overlayfs?

- Ответ
    
    **Образы(images)** - это логическая группировка слоев плюс метаданные о том, что делать при создании контейнера и как собирать слои. Часть этих метаданных заключается в том, что каждый слой знает ID своего родителя.
    
    Итак, что входит в слой? Файлы (и каталоги), которые вы добавили в родительский файл. Существуют также специальные файлы ("whiteout"), которые указывают на то, что что-то было удалено из родительского файла.
    
    Docker-image — шаблон только для чтения (read-only) с набором некоторых инструкций, предназначенных для создания контейнера. Он состоит из слоев, которые Docker комбинирует в один образ при помощи вспомогательной файловой системы UnionFS. Так решается проблема нерационального использования дисковой памяти. Параметры образа определяются в Docker-file.
    

---

### Что такое docker commit

- Ответ
  Это утилита, с помощью которой можно сощздать новый образ на основе контейнера либо перезаписать текущий образ

  Может быть полезно когда ты что ты изменил какой то файл в docker контейнере, и тебе нужно сохранить этот новый рабочий обновленный образ.


---

### Каким образом в docker реализована изоляция контейнеров друг от друга? Какие средства linux для этого используются?(namespace)

- Ответ
    
    Докер используется namespaces. Для создания изолированного рабочего пространства, которое называется контейнером. 
    При запуске контейнера докер создает набор неймспейсов для этого контейнера.

    Эти неймспейсы обеспечивают уровень изоляции. Каждый аспект контейнера выполняется в отдельном контейнере и его доступ ограничен неймспейсом.

    В частности в Docker Engine использует следующее:
    - Пространство имен pid: Изоляция процессов (PID: идентификатор процесса).
    - Пространство имен net: Управление сетевыми интерфейсами (NET: Networking).
    - Пространство имен ipc: Управление доступом к ресурсам IPC (IPC: InterProcess Communication).
    - Пространство имен mnt: Управление точками монтирования файловой системы (MNT: Mount).
    - Пространство имен uts: Изолирование идентификаторов ядра и версий. (UTS: Unix Timesharing System).
        

---

### Почему в контейнере можно увидеть только процессы, запущенные в самом контейнере?

- Ответ

    Это связано с тем, что Docker использует пространство имен PID (Process ID) для обеспечения изоляции процессов в контейнерах. 
    Когда создается новый контейнер, Docker создает новое пространство имен PID для этого контейнера и запускает процесс в этом пространстве имен. 

    В этом изолированном пространстве имен PID относится только к процессам, запущенным в том же контейнере.  
    Это означает, что процесс в контейнере **может видеть только другие процессы в том же контейнере и не имеет возможности видеть процессы, запущенные в других контейнерах или на хост-системе**. 
    Это ключевой аспект изоляции и безопасности, обеспечиваемой контейнерами Docker.
    
---

### В папке /var/lib/docker/ как понять какая папка к какому контейнеру принадлежит

- Ответ

  Например можно попробовать так:
  ```
   docker inspect $(docker ps -qa) |  jq -r 'map([.Name, .GraphDriver.Data.MergedDir]) | .[] | "\(.[0])\t\(.[1])"'
  ```
 


---

### Какие типы сетей есть в докере

- Ответ  
  **bridge** - Это стандартная сеть по умолчанию, которая создает виртуальный мост (bridge) для обмена данными между контейнерами. Каждый контейнер получает собственный IP-адрес из диапазона сети Docker.

  **host** - использует сетевой стек хоста, что означает, что контейнеры не изолированы на уровне сети от хоста. То есть, контейнер не изолирован по портам и делает запросы напрямую через сеть хоста.

  **none** - контейнер не имеет доступа к сети.

  **overlays** - тип сетей которые пересекают несколько узлов. Полезно когда у тебя docker контейнеры запушенны на разных хостах, но они должны общаться между собой. Для реализации этой сети Docker использует технологии, такие как **VXLAN** (Virtual Extensible LAN).

---

### Можно ли настроить сетевое взаимодействие между двумя docker-контейнерами? Как это реализовано?

- Ответ
    
    Можно.
    
    - Контейнеры должны быть частью одной сети
    - Докер создает виртуальную сеть, default bridge и подключает к ней контейнеры. Также, использует драйвер overlay для многохостовых сетей
    - В сети контейнерам назначается айпишник
    - Если контейнеры имеют выход в большую сеть, то они ведут себя как программы на отдельных компах

    Пример с сетевым драйвером bridge:
    1. Создаем сеть
       ```
       docker network create my_network
       ```

    2. Запускаем два контейнера в сети (sleep 1d это для бездействия контейнера в течение дня. Полезно при дебаге порой):
       ```
        docker run -d --name container1 --network my_network alpine sleep 1d
        docker run -d --name container2 --network my_network alpine sleep 1d
       ```

    3. Пробуем попинговать по имени:
       ```
        docker exec -it container1 ping container2
        ubuntu@host:~$ docker exec -it container1 ping container2
        PING container2 (172.18.0.3): 56 data bytes
        64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.110 ms
        64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.083 ms
        64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.111 ms
       ```
    Это работает потому, что когда вы создаете контейнер в сети Docker, он получает собственный IP-адрес в этой сети и добавляет DNS-запись на DNS-сервер сети. 
    Это позволяет контейнерам в одной сети взаимодействовать друг с другом, используя свои имена.
    Если вы хотите создать сеть на нескольких хостах Docker, используйте сетевой драйвер `overlay`.  
    Для этого потребуется Docker Swarm или стороннее хранилище ключевых значений, например Consul или etcd.

---

### Что происходит когда пишешь ENTRYPOINT?

- Ответ
    
    Точка входа в приложение.

    Это инструкция в докерфайле, которая всегда будет выполняться при запуске контейнера. 
    Она часто используется для определения основной команды для запуска контейнера. 
    Например для запуска веб-сервера или какой-либо иной службы. 

    Что происходит пошагово:    
    Инструкция ENTRYPOINT в Dockerfile задает команду, которая всегда будет выполняться при запуске контейнера. Она часто используется для задания основной команды для запуска контейнера, например, для запуска веб-сервера, базы данных или службы.
    Вот что происходит шаг за шагом:  

    1. В процессе сборки образа Docker читает Dockerfile строка за строкой, сверху вниз. Когда Docker встречает инструкцию ENTRYPOINT, он записывает команду и ее аргументы.  

    2. После сборки образа, при запуске контейнера из этого образа Docker выполняет команду, указанную в инструкции ENTRYPOINT. 

    3. Если команда Docker run также включает в себя команду, то она передается в качестве аргумента команде ENTRYPOINT.  

    Например, если у вас есть Dockerfile со следующим ENTRYPOINT:

    ```
    ENTRYPOINT ["/app/start.sh"]
    ```

    И запускается контейнер из этого образа с помощью команды:

    ```
    docker run -it my_image echo "Hello, World!"
    ```

    Докер выполнит команду ENTRYPOINT с командой run в качестве аргумента:

    ```
    /app/start.sh echo "Hello, World!"
    ```

    Обратите внимание, что команду ENTRYPOINT можно отменить при запуске контейнера, используя флаг `--entrypoint` в команде `docker run`.
    В этом основной смысл, что можно переопределить аргумент, или вообще его отменить.

### В чем отличие CMD и ENTRYPOINT

- Ответ
    
    Эти инструкции Dockerfile задают команду, исполняемую при запуске контейнера. При их использовании есть несколько правил, например:
    
    - Должна быть минимум одна из них, CMD или ENTRYPOINT, в Dockerfile.
    - Если контейнер используется как исполняемый файл — ENTRYPOINT должна быть определена.
    - Если контейнер запускается с другими аргументами — CMD будет переопределена.
    
    Инструкция RUN позволяет вам установить ваше приложение и необходимые для него пакеты. Он выполняет любые команды поверх текущего изображения и создает новый слой, фиксируя результаты. Часто в Dockerfile вы найдете несколько инструкций RUN.
    
    Хорошей иллюстрацией инструкции RUN может быть установка нескольких пакетов систем контроля версий:
    
    ```
    RUN apt-get update && apt-get install -y \
      bzr \
      cvs \
      git \
      mercurial \
      subversion
    ```
    
    Обратите внимание, что `apt-get update`и `apt-get install`выполняются в одной инструкции RUN. Это делается для того, чтобы убедиться, что будут установлены самые последние пакеты. Если бы `apt-get install`это была отдельная инструкция RUN, то она бы повторно использовала слой, добавленный `apt-get update`, который мог быть создан давным-давно.
    
    Инструкция CMD позволяет вам установить команду по *умолчанию* , которая будет выполняться только тогда, когда вы запускаете контейнер без указания команды. Если контейнер Docker запускается с командой, команда по умолчанию будет игнорироваться. Если Dockerfile содержит более одной инструкции CMD, все инструкции CMD, кроме последней, игнорируются.
    
    CMD имеет три формы:
    
    - `CMD ["executable","param1","param2"]`
        
        (исполнительная форма, предпочтительнее)
        
    - `CMD ["param1","param2"]`*exec*
        
        (устанавливает дополнительные параметры по умолчанию для ENTRYPOINT в форме
        
    - `CMD command param1 param2`
        
        (форма оболочки)
        
        `docker run -it <image> /bin/bash` - тут при наличии CMD он будет проигнорирован, и будет запущен баш
        
        Инструкция ENTRYPOINT позволяет настроить контейнер, который будет работать как исполняемый файл. Он похож на CMD, потому что также позволяет указать команду с параметрами. Разница заключается в том, что команда ENTRYPOINT и параметры не игнорируются, когда контейнер Docker запускается с параметрами командной строки. (Есть способ игнорировать ENTTRYPOINT, но вряд ли вы это сделаете.)
        
        Докерфайл
        
        ```
        ENTRYPOINT ["/bin/echo", "Hello"]
        CMD ["world"]
        ```
        
        когда контейнер запускается, как `docker run -it <image>`будет производиться вывод
        
        ```
        Hello world
        
        ```
        
        но когда контейнер запускается, `docker run -it <image> John`это приведет к
        
        ```
        Hello John
        ```
        
- Краткий ответ
    
    cmd подставится после entrypoint при запуске. Тем самым можно запускать контейнер с нужными параметрами.
    
    То есть в entrypoint можно передать бинарь, а в cmd передать параметры.
    
    CMD может перетереться просто.
    
---

### Как уменьшить размер образа докера? У нас много COPY, RUN

- Ответ
    1. Использовать специальные облегченные базовые версии докер-образов.
    2. Уменьшать размер слоев, запуская RUN нечасто, объединив команды в одну
    3. Не устанавливать рекомендованные пакеты. И удалять содержимое `/var/lib/apt/lists/*`
    4. Docker-multistage-build. Тут указываем несколько `FROM`. И можно копировать результат одного `FROM-а` в другой
        - Пример
            
            ```docker
            # 1 =====================================
            # специальный образ, который содержит все необходимые 
            # для сборки библиотеки и приложения
            # размер образа ~730mb
            FROM diproart/ruby:2.6.4-alpine3.10 AS builder
            
            # полный набор пакетов
            ENV COMMON_PACKAGES \
            	tzdata \
                ...
                
            ENV ..
            
            RUN set -xe \
                && apk update \
                && apk upgrade \
                && apk add --no-cache --update ${COMMON_PACKAGES} \
                && rm -rf /var/cache/apk/* /tmp/* /var/tmp/*
            
            # additional clean
            #RUN rm -rf /usr/local/bundle/cache/*gem     
            
            RUN mkdir -p /usr/src/app
            WORKDIR /usr/src/app
            COPY . .
            RUN 
            
            # 2 =====================================
            # чистый образ, в который добавим только самое необходимое
            # размер образа ~51mb
            FROM ruby:2.6.4-alpine3.10
            
            # только необходимые для работы 
            # в production пакеты
            ENV PRODUCTION_PACKAGES \
            	tzdata \
                ...
            
            ENV ...
            
            RUN set -xe \
                && apk update \
                && apk upgrade \
                && apk add --no-cache --update ${PRODUCTION_PACKAGES} \
                && rm -rf /var/cache/apk/* /tmp/* /var/tmp/*
            
            RUN mkdir -p /usr/src/app
            WORKDIR /usr/src/app
            
            WORKDIR /usr/src/app
            
            # копируем скомпилированное приложение
            # и пакеты в напрямую в образ из предыдущего шага
            COPY --from=builder /usr/src/app .
            COPY --from=builder /usr/local/bundle/ /usr/local/bundle/
               
            EXPOSE 3000
            ENTRYPOINT [ "bundle", "exec" ]
            CMD [ "rails", "s", "-b", "0.0.0.0" ]
            ```
            
---

### Разработчики собрали образ, и запустили докер контейнер. При запуске выдает ошибку /bin/bash not found. Как диагностировать проблему?

- Ответ

  Попробовать запустить с sh, bash переопределив энтрипоинт
  ```
  docker run  --entrypoint="/bin/sh"  
  ```
  

---

### Какие команды порождают слои?

- Ответ
    
    `RUN` порождает слои
    
---

### Что за none образы можно увидеть в docker images?

- Ответ  
  Каждый образ в докере состоит из слоев, и имеет дочерние связи с другими слоями. По умолчанию они лежат в `/var/lib/docker/graph`.
  И когда мы закачиваем новую версию образа, то образ подгружает слой раз за разом. И получается что none это лишь один из слоев.
  Этот образ называется промежуточным. Их можно увидеть с помощью `docker images -a`
  Также, есть обособленные образы none:none. Например, когда мы собираем примерно такой же образ, но например с иной версией операционной системы.
  И в этом случае будет создан именно такой образ. Поскольку мы пересобрали образ с помощью докерфайла, а старая система стала обособленной.
  
  Можно почистить так:
  ```
  docker rmi $(docker images -f "dangling=true" -q)
  ```


---

### Что такое squash сквош?

- Ответ
    
    Это штука, позволяющая все слои спушить в один. В качестве побочного эффекта - размер образа уменьшается. 
    
    Но он ломает кэширование, поскольку у нас всё в одном слое. 
    
    С одной стороны инструмент мощный. Но нужно обращаться осторожно. 
    Лучше для базового образа использовать. Заранее набросал, и вот у тебя образ.



---

### Что такое Docker squash?

- Ответ
    
    Это утилита на питоне, которая позволяет объединить слои в один.
    
    Также это экспериментальный параметр с помощью которого можно создать сжатый образ.
    

---

### Можно ли ограничить использование ресурсов (cpu, ram, io, network) для docker контейнера? Как это реализовано? (cgroup)**

- Ответ
    
    Можно. И делается через cgroup. В модуле ядра.
    
    А можно посмотреть в докере как ключи ставить
    
    [https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)
    

---

### Для решения каких задач применяется docker-compose?

- Ответ
    
    Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.
    Вы передаёте файл с инструкциями для docker-compose, настроечными файлами, и докер на месте собирает из этого нужную вам комбинацию контейнеров, подтягивает образы нужных версий, пробрасывает в них волюмы с данными, поднимает между ними локальные сети и настраивает порты обмена.

---

### Что такое виртуализация? Чем виртуализация отличается от эмуляции?

- Ответ
    
    Виртуализация очень похожа на эмуляцию, но между ними есть важные различия. В частности, виртуализация обычно относится к использованию виртуальных машин. Виртуализация и эмуляция выполняют одно и то же, но делают это немного по-разному.
    
    Оба предназначены для запуска программного обеспечения в изолированной среде. Виртуализация ориентирована на изоляцию, а эмуляция — на среду. Это означает, что эмуляторы имитируют большее количество оборудования, чем виртуальные машины.
    
    Например, вы не можете запустить систему PlayStation на виртуальной машине. Но вы можете запустить эмулятор PlayStation в виртуальной среде Windows.
    
    Эмуляция-это использование программного обеспечения для обеспечения другой среды выполнения или архитектуры. Например, у вас может быть эмулятор Android, запущенный на коробке Windows. Коробка Windows не имеет того же процессора, что и устройство Android, поэтому эмулятор фактически выполняет приложение Android с помощью программного обеспечения.
    
    Виртуализация-это скорее создание виртуальных барьеров между несколькими виртуальными средами, работающими в одной и той же физической среде. Большая разница заключается в том, что виртуализированная среда представляет собой одну и ту же архитектуру. Виртуализированное приложение может предоставлять виртуализированные устройства, которые затем преобразуются в физические устройства, и узел виртуализации контролирует, какая виртуальная машина имеет доступ к каждому устройству или части устройства. Однако фактическое выполнение чаще всего все еще выполняется изначально, а не с помощью программного
    

### В чем разница между `docker stop` и `docker pause`?

- Ответ
    
    В том, что они посылают разные сигналы 
    
    docker pause - SIGSTOP(19), что приостанавливает процессы в контейнере
    
    docker stop - SIGTERM(15) и SIGKILL(9) использует к главному процессу контейнера
    

### Что такое слои в докере?

- Ответ
    
    По сути, слой или *слой образа*
     - это изменение образа или **промежуточного образа**. Каждая команда, указанная (  
    `FROM`,  
    `RUN`,  
    `COPY`  
    и т.д.) в вашем Dockerfile вызывает предыдущий образ изменения, создавая тем самым новый слой. Вы можете думать об этом как о внесении изменений при использовании git: вы добавляете изменение файла, затем еще одно, затем добавляя ещё одно, и слои накладываются один за другим.

    Так же любые изменения, которые происходят в docker контейнере, автоматически записываются в новый слой.
    

### В чем разница между ADD и COPY

- Ответ  
    В Dockerfile, инструкции `ADD` и `COPY` обе используются для копирования файлов и директорий из локальной файловой системы в образ контейнера, но между ними есть несколько важных различий:  
    * **COPY** поддерживает **только** базовое копирование локальных файлов в контейнер  
    * **ADD** имеет дополнительный функционал, к примеру, может извлекать архивы (напр, .tar, .tar.gz, .zip и другие форматы) и загружать файлы по URL. Но если, например, копировать через него архив, то он распакуется как каталог. Это уменьшает размер образа  

  В большинстве случаев предпочтительнее использовать COPY, так как это более предсказуемо и ясно, а ADD стоит использовать только тогда, когда вам действительно нужны её дополнительные возможности, такие как извлечение архивов или загрузка файлов по URL.  
    

### Почему latest образы использовать нежелательно?

- Ответ
    
    Сложно в отладке как минимум. Не разобраться какая именно версия закосячила. А так прод работает на определенной версии, пусть дальше на ней и работает.
    Помимо этого это небезопасно. Никто не знает что выкатит разработчик в новой версии. Может не быть обратной совместимости в проекте.
    

---

### В чем отличие ARG от ENV?

- Ответ
    
    **ENV** позволяет создавать переменные окружения, которые будут работать во время работы контейнера.
    
    **ARG** позволяет закинуть переменные, которые будут доступны во время сборки. Но они недоступны в контейнере. Однако через `ARG` можно задавать значения переменных по умолчанию для `ENV`

---

### От кого по умолчанию запускается контейнер? Почему это плохо?

- Ответ
    
    Процесс внутри пользователя запускается от root. id = 0.
    
    Лучше вот так делать
    
    ```docker
    FROM alpine
    RUN groupadd -r myuser && useradd -r -g myuser
    <Здесь еще можно выполнять команды от root-пользователя, например, ставить пакеты>
    USER myuser
    ```
    
    Можно таким образом нарушить изоляцию и получить рутовый доступ.
    
    Ну и не все запускают от рута в итоге
    
---

### Как убить контейнер изнутри?

- Ответ
    
    Через sigkill нельзя. Нужен обработчик сигнала. Sigkill я зарегистрировать не смогу. И игнорировать этот сигнал тоже. Но можно обрабатывать  sigterm. И его использовать для выхода из приложения.
    
    [https://medium.com/@andrestc/killing-a-container-from-the-inside-b4923f3a4182](https://medium.com/@andrestc/killing-a-container-from-the-inside-b4923f3a4182)
    

---

### Возможен ли самостоятельный перезапуск контейнера?

- Ответ
    
    Да, можно вот так указать:
    
    `docker run --restart=always`
    
---

### Какие есть best practices для написания Dockerfile?

- Ответ
    1. Запускать только один процесс на контейнер.
    2. Стараться объединять несколько команд **RUN** в одну для уменьшения количества слоёв образа.
    3. Частоизменяемые слои образа необходимо располагать ниже по уровню,
    чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все
    нижеследующие слои будут пересобираться.
    4. Указывать явные версии образов в инструкции **FROM**, чтобы избежать случая, когда выйдет новая версия образа с тегом **latest**.
    5. При установке пакетов указывать версии пакетов.
    6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
    7. Использовать **multistage build** для сборки артефакта в одном контейнере и размещении его в другом.

---

### Что такое ката kata контейнер?

- Ответ
    
    Это иная реализация контейнеров. Которые работают в оси под открытой инициативой. **Kata Containers** объединяют преимущества контейнеров и виртуальных машин (VM). Они обеспечивают более высокий уровень **изоляции и безопасности** для приложений, сохраняя при этом **лёгкость и скорость работы контейнеров**.  
    Если обычные контейнеры используют стандартные механизмы контейнеризации Linux, у **Kata Containers** используются qemu, kvm.  
    
    Контейнер на стероидах. Больше для безопасности придумано.


---

### CRI, CSI, CNI, что это ?

- Ответ 

    **CRI** ( container runtime interface ) - это интерфейс который отвечает за жизенный цикл контейнера 
    и среду выполнения этого контейнера ( docker, containered и тд. )

    **CSI** ( container storage interface ) - это интерфейс который позволяет, как я понял,
    стандартизировать подключения каких то хранилищ к контейнеру

    **CNI** ( container network interface ) - это интерфейс, который позволяет тюнить сетевые взаимодействия
    как между контейнерами, так и контейнера к какому-то сервису

    | Термин | Описание | Область применения | Уровень взаимодействия | Примеры реализации |
    |--------|----------|--------------------|-----------------------|---------------------|
    | **CRI** | Интерфейс для управления жизненным циклом контейнеров в Kubernetes. Позволяет Kubernetes взаимодействовать с различными средами выполнения контейнеров. | Оркестрация и управление контейнерами. | Инфраструктурный уровень, взаимодействие с контейнерами. | Docker, containerd, CRI-O. |
    | **CSI** | Стандарт для подключения систем хранения данных к контейнерам. Позволяет разработчикам интегрировать разные решения для управления данными в контейнерах. | Хранение и доступ к данным в контейнерах. | Инфраструктурный уровень, взаимодействие с системами хранения. | OpenEBS, Rook, Portworx. |
    | **CNI** | Спецификация для настройки сетевых интерфейсов контейнеров. Управляет сетевыми настройками и политиками безопасности для контейнеров. | Управление сетями и коммуникацией между контейнерами. | Интерфейс для сетевых плагинов, работающих на уровне контейнеров. | Calico, Flannel, Weave Net. |
    
---
#devops #docker 