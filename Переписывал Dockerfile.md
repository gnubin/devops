Отличный и очень конкретный вопрос! Это как раз та деталь, которая отличает человека, который просто запускал контейнеры, от того, кто глубоко вникал в процесс миграции. Вот несколько реальных кейсов по исправлению Dockerfile при переходе, например, с Java на Go.

### Общий принцип изменений

*   **Для Java:** Используется тяжелый образ с JDK (Java Development Kit) для сборки, и часто (в идеале) многоСтейджиный Dockerfile, где финальный образ использует только JRE (Java Runtime Environment) или еще лучше — JLink для создания минимального рантайма.
*   **Для Go:** Ключевое преимущество — статическая компиляция. Мы компилируем бинарник под нужную архитектуру, и ему **не нужны никакие зависимости в рантайме**. Это позволяет использовать минимальные образы вроде `scratch` (пустой) или `alpine` (очень маленький).

---

### Кейс 1: Кардинальное изменение — от многослойного Java-образа к минимальному Go-образу

**Было (Java):**
```dockerfile
# Используем образ с Maven и JDK для сборки
FROM maven:3.8.6-openjdk-17 AS builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests # Собираем fat JAR

# Финальный образ
FROM openjdk:17-jre-slim
WORKDIR /app
COPY --from=builder /app/target/my-app-*.jar /app/app.jar
# Устанавливаем зависимости для wait-for-it скрипта, если нужен
# RUN apt-get update && apt-get install -y netcat-openbsd && rm -rf /var/lib/apt/lists/*
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```

**Стало (Go):**
```dockerfile
# Двухэтапная сборка: первый этап — компиляция
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download # Кэшируем зависимости
COPY . .
# Статически компилируем под Linux (CGO_ENABLED=0 убирает зависимость от libc)
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/my-service ./cmd/main.go

# Второй этап — создание минимального финального образа
FROM scratch
# Можно также использовать FROM alpine:latest, если нужна shell для дебага, но scratch меньше.
WORKDIR /app
COPY --from=builder /app/my-service /app/my-service
# Копируем SSL-сертификаты, иначе приложение не сможет делать HTTPS-вызовы вовне!
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
EXPOSE 8080
# Запускаем скомпилированный бинарник напрямую
CMD ["/app/my-service"]
```

**Какие правки и почему:**
1.  **Базовый образ:** Сменили `maven` + `openjdk` (весом МБ каждый) на `golang:alpine` (для сборки) и `scratch` (для рантайма, **0 МБ**). Итоговый образ уменьшился с ~200-300 МБ до **10-20 МБ**.
2.  **Процесс сборки:** Заменили вызов `mvn package` на `go build`.
3.  **Артефакт:** Вместо копирования JAR-файла копируем статический бинарник.
4.  **Критически важное добавление:** Копирование файла `ca-certificates.crt`. Без этого бинарник Go, скомпилированный с `CGO_ENABLED=0`, не сможет работать с TLS (например, вызывать другие API по HTTPS). Это очень частая и важная правка.
5.  **Запуск:** CMD теперь запускает напрямую бинарник, а не виртуальную машину `java`.

---

### Кейс 2: Оптимизация для разных стадий проекта

Часто миграция происходит постепенно. Пока один сервис уже на Go, другой еще на Java.

**Правки в пайплайн (GitLab CI):**
Раньше у вас мог быть один общий шаблон (`.gitlab-ci.yml`) для сборки всех проектов. После миграции пришлось его доработать.

*   **Было:** Один job `build`, который предполагал, что проект — это Maven-проект.
    ```yaml
    build:
      image: maven:3.8.6-openjdk-17
      script:
        - mvn clean package
      artifacts:
        paths:
          - target/*.jar
    ```

*   **Стало:** Введение переменных или разных путей для определения типа проекта.
    **Вариант A (с тэгами):**
    ```yaml
    build:
      image: $BUILD_IMAGE # Используем переменную
      script:
        - if [ "$PROJECT_TYPE" == "java" ]; then mvn clean package; fi
        - if [ "$PROJECT_TYPE" == "go" ]; then CGO_ENABLED=0 GOOS=linux go build -o service-binary ./cmd; fi
      artifacts:
        paths:
          - if [ "$PROJECT_TYPE" == "java" ]; then target/*.jar; fi
          - if [ "$PROJECT_TYPE" == "go" ]; then service-binary; fi
    ```
    *В этом случае в настройках проекта или в `gitlab-ci.yml` задаются переменные `BUILD_IMAGE=maven:3.8.6-openjdk-17` и `PROJECT_TYPE=java` (или `golang:alpine` и `go`).*

---

### Кейс 3: Внесение правок для корректной работы в Kubernetes

Образы на основе `scratch` или `alpine` максимально минималистичны. В них нет многих инструментов, что может усложнить жизнь.

**Проблема 1: Невозможно выполнить `kubectl exec` для дебага.**
В Java-образе был bash. В Go-образе на основе `scratch` нет даже shell! Команда `kubectl exec -it my-pod -- sh` не сработает.

*   **Решение:** Для стендов **dev/test** можно пожертвовать минимализмом ради удобства отладки и использовать `alpine` в качестве базового образа. В продакшен всегда деплоить образ на `scratch`.
    ```dockerfile
    # Финальный образ для dev/test
    FROM alpine:latest
    WORKDIR /app
    COPY --from=builder /app/my-service /app/my-service
    COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
    # Устанавливаем shell и базовые утилиты
    RUN apk add --no-cache bash
    EXPOSE 8080
    CMD ["/app/my-service"]
    ```

**Проблемa 2: Readiness/Liveness пробы.**
В Java-приложении пробы часто делались через HTTP-эндпоинт (`http-get`). В Go-приложении это осталось так же. Но если контейнер падает, из-за отсутствия shell некоторые инструменты логирования могут работать хуже.

*   **Решение:** Убедиться, что HTTP-эндпоинты для проб (`/health`, `/ready`) поднялись **до того**, как проба начнет проверяться. В Kubernetes правильно выставить `initialDelaySeconds`.

**Проблема 3: Логирование.**
Java-приложение по умолчанию пишет логи в stdout. Go-приложение тоже должно быть сконфигурировано на запись в stdout, а не в файл. Это критично для работы любого сборщика логов (например, Loki).

*   **Решение:** Проверить конфигурацию логгера в коде на Go (часто используются библиотеки like `zap` или `logrus`) и гарантировать, что логи идут в stdout в формате, понятном для парсера.

### Итоговый список правок для DevOps-инженера:

1.  **Полная переработка Dockerfile:** Смена базовых образов, оптимизация под статическую линковку Go.
2.  **Добавление CA-сертификатов:** Обязательное копирование `/etc/ssl/certs/ca-certificates.crt` для работы с HTTPS.
3.  **Адаптация CI/CD пайплайна:** Введение логики для сборки разных типов проектов (Java vs. Go) в одном пайплайне.
4.  **Настройка инструментов:** Обновление SAST-сканеров (например, настройка `gosec` для Go-проектов).
5.  **Решение проблем рантайма:** Принятие решения об использовании `scratch` (продакшен) vs. `alpine` (дев/отладка).
6.  **Документирование:** Обновление инструкций по сборке и запуску для разработчиков.